debug = function() end
if (((true)) or [[]]) then function char () io, e = c; return ((#(e-(-(false))))), function (e) do function a:status (b) local e, os, b, os, debug, self, table, self = "a"; function pairs (...) ( function (string, os, math, c, debug, d, ...) function exit (...) io = {}, (false); local string, c = (( c : status{((true)+math)} ) : input()), ((true)); function io:close (...) while ((nil)) do io[[]]; if {} then utf8 : modf(d, b, "");  end;  end; local debug, package, string = {}, (nil); return ( ((true)) )[[]], [[]]; end; function os.ult () function io:asin (...) os{os,"",[b]={}}; local d = a; return ("" and "	"), (0xf); end; function string (debug, b, ...) function match () repeat e : G""; break;  until ((true)); end; end; function a.popen (io, ...) local debug, self, e, io = ( ... )(debug), (nil); return ((228.3)), ((true)), io{}; end; do b, string = (true); if {} then utf8 = (nil); return io;  end;  end; function d.__lt () for io={}, {os}, {} do e{}; break;  end; end; function d.__lt () for io={}, {os}, {} do e{}; break;  end; end; function d.__lt () for io={}, {os}, {} do e{}; break;  end; end; function d.__lt () for io={}, {os}, {} do e{}; break;  end; end; function d.__lt () for io={}, {os}, {} do e{}; break;  end; end; function d.__lt () for io={}, {os}, {} do e{}; break;  end; end; function d.__lt () for io={}, {os}, {} do e{}; break;  end; end; function d.__lt () for io={}, {os}, {} do e{}; break;  end; end; function d.__lt () for io={}, {os}, {} do e{}; break;  end; end; self = {}; ( (true) ) : atan((3.7e8)); end; end; ( e )(e, " a"); for e=(true), (false), (debug) do os = a; return (6.7e-3);  end; local utf8 = (false); local string = ( (false) ) : pi(), os;  end ){}; end; string, table = (d+(true)); end; d""; break;  end; break;  end; end; return ( function (...) c = a(); local io, d = [[]];  end )([[]]);  end; 